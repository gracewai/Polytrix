var Q = require('q');
var PassThrough = require('stream').PassThrough;
var request = require('request');
var config = require('../../config').tesseract;
var mime = require('mime');
// stream
//	createAndUploadStream(access_token,refresh_token,destinationFileId,readStream,mimeType,filename)
//	uploadStream(access_token,refresh_token,fileId,readStream,mimeType,overwrite,parent_rev)
//	downloadStream(access_token,refresh_token,fileId)

module.exports.createAndUploadStream = function(access_token,refresh_token,destinationFileId,readStream,mimeType,filename){
	var url=config.domain + 'vault/file/new/' + filename;

	return Q.Promise(function(resolve,reject,notify){
		var req = request.put({
			url:url,
			qs:{
				destinationId:destinationFileId
			},
			headers:{
				Authorization: "Bearer " + access_token
			},
			multipart:[
				{
					'content-type': mimeType,
					body: readStream
				}
			]
		},
		function(error,response,body){
				if(!error){
					if(response.statusCode === 200){
						resolve(body);
					}else{
						console.log('response.statusCode: ' + response.statusCode);
						if(typeof body === 'string'){
							body = JSON.parse(body);
						}
						body.status = response.statusCode;
						console.log(body);
						reject(body);
					}
				}else{
					reject(error);
				}
			});
		//resolve(req);
	})
	.then(function(body){
		return transform.getFileInformation(JSON.parse(body));
	}).then(function(body){
		body.success = true;
		return body;
	})
	.catch(function(err){
		return transformError(err);
	});
};

module.exports.uploadStream = function(access_token,refresh_token,fileId,readStream,mimeType,overwrite,parent_rev){

	var url= config.domain + '/vault/file/' + fileId;
	return Q.Promise(function(resolve,reject,notify){
		var req = request.put({
                url:url,
                qs:{
                    destinationId:destinationFileId,
                    replace:overwrite
                },
                headers:{
                    Authorization: "Bearer " + access_token
                },
                multipart:[
                    {
                        'content-type': mimeType,
                        body: readStream
                    }
                ]
			},
			function(error,response,body){
				if(!error){
					if(response.statusCode === 200){
						resolve(body);
					}else{
						console.log('response.statusCode: ' + response.statusCode);
						if(typeof body === 'string'){
							body = JSON.parse(body);
						}
						body.status = response.statusCode;
						console.log(body);
						reject(body);
					}
				}else{
					reject(error);
				}
			}
		);
		readStream.pipe(req);
		//resolve(req);
	})
	.then(function(body){
		return transform(JSON.parse(body));
	})
	.catch(function(err){
		return transformError(err);
	});
};
module.exports.downloadStream = function(access_token,refresh_token,fileId){
	var url= config.domain + '/vault/file/' + fileId + '/content';
	return Q.Promise(function(resolve,reject,notify){
		var req = request.get({
			url:url,
			qs:{
				access_token: access_token
			}}
		);
		var myResponse = new PassThrough();
		req.pipe(myResponse);
		req.on('response', function(response) {
			if(response.statusCode == 200){
				myResponse.mimeType = response.headers['content-type'];
				resolve(myResponse);
			}else{
				var body;
				console.log('response.statusCode: ' + response.statusCode);
				response.setEncoding('utf8');
				response.on('data',function(chunk){
					body += chunk;
				});
				response.on('end',function(){
					body = JSON.parse(body);
					body.status = response.statusCode;
					reject(body);
				});
			}
		});
		req.on('error', function(error){
			reject(error);
		});
		//resolve(req);
	})
	.catch(function(error){
		return transformError(error);
	});
};

function transform(body){
	var data = {
		success:true,
		identifier:body.id,
		name:body.name,
		_raw:body
	};
	return data;
}

function transformError(err){
	var result = {
		success: false,
		error_code: err.status,
		msg: err.code=='resource_not_found' || err.error && err.error.code == 'resource_not_found' ?
				'404 file not found' : err.message || err.error.message
	};
	if(err instanceof Error){
		console.log(err.stack);
		result.error_code = 500;
		result.msg = err.message;
	}
	return result;
}